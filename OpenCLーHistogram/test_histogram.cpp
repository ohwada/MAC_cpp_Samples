/**
 * OpenCL Sample
 * 2020-01-01 K.OHWADA
 *  original : https://github.com/bgaster/opencl-book-samples/tree/master/src/Chapter_14/histogram
 */

//
// Book:      OpenCL(R) Programming Guide
// Authors:   Aaftab Munshi, Benedict Gaster, Timothy Mattson, James Fung, Dan Ginsburg
// ISBN-10:   0-321-74964-2
// ISBN-13:   978-0-321-74964-2
// Publisher: Addison-Wesley Professional
// URLs:      http://safari.informit.com/9780132488006/
//            http://www.openclprogrammingguide.com
//


#include "histogram_util.hpp"



// fill an image of w x h pixels with 4-channels / pixel with random data
// each channel is an unisgned 8-bit value
//
static void *
create_image_data_unorm8(int w, int h)
{
    unsigned char   *p = (unsigned char *)malloc(w * h * 4);
    int             i;
    
    // generate values ​​from random numbers
    for (i=0; i<w*h*4; i++)
        p[i] = (unsigned char)(rand() & 0xFF);
    return (void *)p;
}


// fill an image of w x h pixels with 4-channels / pixel with random data
// each channel is a single precision floating-point value
//
static void *
create_image_data_fp32(int w, int h)
{
    float   *p = (float *)malloc(w * h * 4 * sizeof(float));
    int     i;
    
    for (i=0; i<w*h*4; i++)
        p[i] = (float)rand() / (float)RAND_MAX;

    return (void *)p;
}


// generate the reference results for unsigned 8-bit RGBA image.  
// this reference result will be compared with histogram results generated by the OpenCL device.
//
 static void *
generate_reference_histogram_results_unorm8(void *image_data, int w, int h)
{
    unsigned int    *ref_histogram_results = (unsigned int *)malloc(256 * 3 * sizeof(unsigned int));
    unsigned char   *img = (unsigned char *)image_data;
    unsigned int    *ptr = ref_histogram_results;
    int             i;
    
    memset(ref_histogram_results, 0x0, 256 * 3 * sizeof(unsigned int));

// Red
    for (i=0; i<w*h*4; i+=4)
    {
        int indx = img[i];
        ptr[indx]++;
    }
    
// Green
    ptr += 256;
    for (i=1; i<w*h*4; i+=4)
    {
        int indx = img[i];
        ptr[indx]++;
    }

// Blue
    ptr += 256;
    for (i=2; i<w*h*4; i+=4)
    {
        int indx = img[i];
        ptr[indx]++;
    }
    
    return ref_histogram_results;
}


// generate the reference results for floating-point RGBA image.  
// this reference result will be compared with histogram results generated by the OpenCL device.
//
static void *
generate_reference_histogram_results_fp32(void *image_data, int w, int h)
{
    unsigned int    *ref_histogram_results = (unsigned int *)malloc(257 * 3 * sizeof(unsigned int));
    float           *img = (float *)image_data;
    unsigned int    *ptr = ref_histogram_results;
    int             i;
    
    memset(ref_histogram_results, 0x0, 257 * 3 * sizeof(unsigned int));
    for (i=0; i<w*h*4; i+=4)
    {
        float           f = img[i];
        unsigned int    indx;
        if (f > 1.0f)
          f = 1.0f;
          
        f *= 256.0f;
        indx = (unsigned int)f;
        ptr[indx]++;
    }
    
    ptr += 257;
    for (i=1; i<w*h*4; i+=4)
    {
        float           f = img[i];
        unsigned int    indx;
        if (f > 1.0f)
          f = 1.0f;
          
        f *= 256.0f;
        indx = (unsigned int)f;
        ptr[indx]++;
    }

    ptr += 257;
    for (i=2; i<w*h*4; i+=4)
    {
        float           f = img[i];
        unsigned int    indx;
        if (f > 1.0f)
          f = 1.0f;
          
        f *= 256.0f;
        indx = (unsigned int)f;
        ptr[indx]++;
    }
    
    return ref_histogram_results;
}


/**
 * verify_histogram_results
 */
 int
verify_histogram_results(const char *str, unsigned int *histogram_results, unsigned int *ref_histogram_results, int num_entries)
{
    int     i;
    
    for (i=0; i<num_entries; i++)
    {
        if (histogram_results[i] != ref_histogram_results[i])
        {
            printf("%s: verify_histogram_results failed for indx = %d, gpu result = %d, expected result = %d\n", 
                                                            str, i, histogram_results[i], ref_histogram_results[i]);
            return -1;
        }
    }
    
    printf("%s: VERIFIED\n", str);
    return 0;
}


/**
 * test_histogram
 */
int
test_histogram()
{
    const int IMAGE_WIDTH = 1920;
    const int IMAGE_HEIGHT = 1080;

    cl_kernel           histogram_rgba_unorm8;
    cl_kernel           histogram_rgba_fp;
    cl_kernel           histogram_sum_partial_results_unorm8;
    cl_kernel           histogram_sum_partial_results_fp;
    cl_image_format     image_format;

    size_t              global_work_size[2];
    size_t              local_work_size[2];
    size_t              partial_global_work_size[2];
    size_t              partial_local_work_size[2];
    size_t              workgroup_size;
    size_t              num_groups;

    unsigned int        *ref_histogram_results, *histogram_results;

    void                *image_data_unorm8;
    cl_mem              input_image_unorm8;
    void                *image_data_fp32;
    cl_mem              input_image_fp32;
    cl_mem              histogram_buffer;
    cl_mem              partial_histogram_buffer;
    cl_event            events[2];
    cl_ulong            time_start, time_end;
	size_t              src_len[1];
    char                *source[1];
    int                 i, err;

    // start
    unsigned int now = (unsigned int)time(NULL);
    srand(now);  

    cl_device_id device = getDevice();
    if(device == 0){
        return EXIT_FAILURE;
    }

    check32bitLocalAtomicsSupport(device);

    cl_context context = createContext(device);
    if(!context){
        return EXIT_FAILURE;
    }

    cl_command_queue queue = createCommandQueue(context, device);
    if(!queue){
        return EXIT_FAILURE;
    }
 
    cl_program program = createProgramFromFile(context, device, KERNEL_FILENAME);
    if(program == 0){
        return EXIT_FAILURE;
    }

    program = createProgramFromFile(context, device, KERNEL_FILENAME);
    if(program == 0){
        return EXIT_FAILURE;
    }

    histogram_rgba_unorm8 = clCreateKernel(program, "histogram_image_rgba_unorm8", &err);
    if(!histogram_rgba_unorm8 || err)
    {
        printf("clCreateKernel() failed creating kernel void histogram_rgba_unorm8(). (%d)\n", err);
        return EXIT_FAILURE;
    }

    histogram_rgba_fp = clCreateKernel(program, "histogram_image_rgba_fp", &err);
    if(!histogram_rgba_fp || err)
    {
        printf("clCreateKernel() failed creating kernel void histogram_image_rgba_fp(). (%d)\n", err);
        return EXIT_FAILURE;
    }
    histogram_sum_partial_results_unorm8 = clCreateKernel(program, "histogram_sum_partial_results_unorm8", &err);
    if(!histogram_sum_partial_results_unorm8 || err)
    {
        printf("clCreateKernel() failed creating kernel void histogram_sum_partial_results_unorm8(). (%d)\n", err);
        return EXIT_FAILURE;
    }
    histogram_sum_partial_results_fp = clCreateKernel(program, "histogram_sum_partial_results_fp", &err);
    if(!histogram_sum_partial_results_fp || err)
    {
        printf("clCreateKernel() failed creating kernel void histogram_sum_partial_results_fp(). (%d)\n", err);
        return EXIT_FAILURE;
    }

    histogram_buffer = createHistogramBuffer(context);
    if (!histogram_buffer)
    {
        return EXIT_FAILURE;
    }

    image_format.image_channel_order = CL_RGBA;
    image_format.image_channel_data_type = CL_UNORM_INT8;
    image_data_unorm8 = create_image_data_unorm8(IMAGE_WIDTH, IMAGE_HEIGHT);
    input_image_unorm8 = clCreateImage2D(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,  
                                            &image_format, IMAGE_WIDTH, IMAGE_HEIGHT, 0, image_data_unorm8, &err);
    if (!input_image_unorm8 || err)
    {
        printf("clCreateImage2D() failed. (%d)\n", err);
        return EXIT_FAILURE;
    }
    image_format.image_channel_order = CL_RGBA;
    image_format.image_channel_data_type = CL_FLOAT;
    image_data_fp32 = create_image_data_fp32(IMAGE_WIDTH, IMAGE_HEIGHT);
    input_image_fp32 = clCreateImage2D(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,  
                                            &image_format, IMAGE_WIDTH, IMAGE_HEIGHT, 0, image_data_fp32, &err);
    if (!input_image_fp32 || err)
    {
        printf("clCreateImage2D() failed. (%d)\n", err);
        return EXIT_FAILURE;
    }
    
    /************  Testing RGBA 8-bit histogram **********/
    // calculate in Two steps
    // (1) calculate by dividing image
    // (2) sum the values ​​calculated by dividing     

    std::cout << "testing RGBA 8-bit histogram" << std::endl;

    clGetKernelWorkGroupInfo(histogram_rgba_unorm8, device, CL_KERNEL_WORK_GROUP_SIZE, sizeof(size_t), &workgroup_size, NULL);
    {
        size_t  gsize[2];
        int     w;
        
        if (workgroup_size <= 256)
        {
            // divide 16
            gsize[0] = 16;
            gsize[1] = workgroup_size / 16;
        }
        else if (workgroup_size <= 1024)
        {
            // divide 16
            gsize[0] = workgroup_size / 16;
            gsize[1] = 16;
        }
        else
        {
            // divide 32
            gsize[0] = workgroup_size / 32;
            gsize[1] = 32;
        }
        
        local_work_size[0] = gsize[0];
        local_work_size[1] = gsize[1];
        
        w = (IMAGE_WIDTH + NUM_PIXELS_PER_WORK_ITEM - 1) / NUM_PIXELS_PER_WORK_ITEM;
        global_work_size[0] = ((w + gsize[0] - 1) / gsize[0]);
        global_work_size[1] = ((IMAGE_HEIGHT + gsize[1] - 1) / gsize[1]);

        num_groups = global_work_size[0] * global_work_size[1];    
        global_work_size[0] *= gsize[0];
        global_work_size[1] *= gsize[1];
        std::cout << "num_groups = " << num_groups << std::endl;
    }    

    partial_histogram_buffer = createPartialHistogramBuffer(context,   num_groups);
    if (!partial_histogram_buffer)
    {
        return EXIT_FAILURE;
   }

    clSetKernelArg(histogram_rgba_unorm8, 0, sizeof(cl_mem), &input_image_unorm8);
    clSetKernelArg(histogram_rgba_unorm8, 1, sizeof(int), &NUM_PIXELS_PER_WORK_ITEM);
    clSetKernelArg(histogram_rgba_unorm8, 2, sizeof(cl_mem), &partial_histogram_buffer);
    
    clSetKernelArg(histogram_sum_partial_results_unorm8, 0, sizeof(cl_mem), &partial_histogram_buffer);
    clSetKernelArg(histogram_sum_partial_results_unorm8, 1, sizeof(int), &num_groups);
    clSetKernelArg(histogram_sum_partial_results_unorm8, 2, sizeof(cl_mem), &histogram_buffer);

    // verify that the kernel works correctly.  also acts as a warmup
    std::cout << "Step1: " << global_work_size[0]  << ",  " << global_work_size[1] << std::endl;
    err = clEnqueueNDRangeKernel(queue, histogram_rgba_unorm8, 2, NULL, global_work_size, local_work_size, 0, NULL, NULL);
    if (err)
    {
        printf("clEnqueueNDRangeKernel() failed for histogram_rgba_unorm8 kernel. (%d)\n", err);
        return EXIT_FAILURE;
    }
    
    // verify that the kernel works correctly.  also acts as a warmup
    clGetKernelWorkGroupInfo(histogram_sum_partial_results_unorm8, device, CL_KERNEL_WORK_GROUP_SIZE, sizeof(size_t), &workgroup_size, NULL);
    if (workgroup_size < 256)
    {
        printf("A min. of 256 work-items in work-group is needed for histogram_sum_partial_results_unorm8 kernel. (%d)\n", (int)workgroup_size);
        return EXIT_FAILURE;
    }

    partial_global_work_size[0] = 256*3;
    partial_local_work_size[0] = (workgroup_size > 256) ? 256 : workgroup_size;

    std::cout << "Step 2: " << partial_global_work_size[0]  << ",  " << partial_global_work_size[1] << std::endl;
    err = clEnqueueNDRangeKernel(queue, histogram_sum_partial_results_unorm8, 1, NULL, partial_global_work_size, partial_local_work_size, 0, NULL, NULL);
    if (err)
    {
        printf("clEnqueueNDRangeKernel() failed for histogram_sum_partial_results_unorm8 kernel. (%d)\n", err);
        return EXIT_FAILURE;
    }

    ref_histogram_results = (unsigned int *)generate_reference_histogram_results_unorm8(image_data_unorm8, IMAGE_WIDTH, IMAGE_HEIGHT);

    histogram_results = (unsigned int *)malloc(257*3*sizeof(unsigned int));

    err = clEnqueueReadBuffer(queue, histogram_buffer, CL_TRUE, 0, 256*3*sizeof(unsigned int), histogram_results, 0, NULL, NULL);
    if (err)
    {
        printf("clEnqueueReadBuffer() failed. (%d)\n", err);
        return EXIT_FAILURE;
    }

    verify_histogram_results("Image Histogram for image type = CL_RGBA, CL_UNORM_INT8", histogram_results, ref_histogram_results, 256*3);
    
    std::string OUTPUT = "test_hist.txt";
    save_histogram(OUTPUT, histogram_results);

    // now measure performance
    err = clEnqueueMarker(queue, &events[0]);
    if (err)
    {
        printf("clEnqeueMarker() failed for histogram_rgba_unorm8 kernel. (%d)\n", err);
        return EXIT_FAILURE;
    }
    for (i=0; i<NUM_ITERATIONS; i++)
    {
        err = clEnqueueNDRangeKernel(queue, histogram_rgba_unorm8, 2, NULL, global_work_size, local_work_size, 0, NULL, NULL);
        if (err)
        {
            printf("clEnqueueNDRangeKernel() failed for histogram_rgba_unorm8 kernel. (%d)\n", err);
            return EXIT_FAILURE;
        }
        
        err = clEnqueueNDRangeKernel(queue, histogram_sum_partial_results_unorm8, 1, NULL, partial_global_work_size, partial_local_work_size, 0, NULL, NULL);
        if (err)
        {
            printf("clEnqueueNDRangeKernel() failed for histogram_sum_partial_results_unorm8 kernel. (%d)\n", err);
            return EXIT_FAILURE;
        }        
    }
    err = clEnqueueMarker(queue, &events[1]);
    if (err)
    {
        printf("clEnqeueMarker() failed for histogram_rgba_unorm8 kernel. (%d)\n", err);
        return EXIT_FAILURE;
    }
    err = clWaitForEvents(1, &events[1]);
    if (err)
    {
        printf("clWaitForEvents() failed for histogram_rgba_unorm8 kernel. (%d)\n", err);
        return EXIT_FAILURE;
    }    
    
    err = clGetEventProfilingInfo(events[0], CL_PROFILING_COMMAND_QUEUED, sizeof(cl_long), &time_start, NULL);
    err |= clGetEventProfilingInfo(events[1], CL_PROFILING_COMMAND_END, sizeof(cl_long), &time_end, NULL);
    if (err)
    {
        printf("clGetEventProfilingInfo() failed for histogram_rgba_unorm8 kernel. (%d)\n", err);
        return EXIT_FAILURE;
    }    
        
    printf("Image dimensions: %d x %d pixels, Image type = CL_RGBA, CL_UNORM_INT8\n", IMAGE_WIDTH, IMAGE_HEIGHT);
    printf("Time to compute histogram = %g ms\n", (double)(time_end - time_start) * 1e-9 * 1000.0 / (double)NUM_ITERATIONS);
    
    clReleaseEvent(events[0]);
    clReleaseEvent(events[1]);

    /************  Testing RGBA 32-bit fp histogram **********/

    std::cout << "testing RGBA  32-bit fp histogram" << std::endl;

    clGetKernelWorkGroupInfo(histogram_rgba_fp, device, CL_KERNEL_WORK_GROUP_SIZE, sizeof(size_t), &workgroup_size, NULL);
    {
        size_t  gsize[2];
        int     w;
        
        if (workgroup_size <= 256)
        {
            gsize[0] = 16;
            gsize[1] = workgroup_size / 16;
        }
        else if (workgroup_size <= 1024)
        {
            gsize[0] = workgroup_size / 16;
            gsize[1] = 16;
        }
        else
        {
            gsize[0] = workgroup_size / 32;
            gsize[1] = 32;
        }
        
        local_work_size[0] = gsize[0];
        local_work_size[1] = gsize[1];
        
        w = (IMAGE_WIDTH + NUM_PIXELS_PER_WORK_ITEM - 1) / NUM_PIXELS_PER_WORK_ITEM;
        global_work_size[0] = ((w + gsize[0] - 1) / gsize[0]);
        global_work_size[1] = ((IMAGE_HEIGHT + gsize[1] - 1) / gsize[1]);

        num_groups = global_work_size[0] * global_work_size[1];    
        global_work_size[0] *= gsize[0];
        global_work_size[1] *= gsize[1];
    }    

    partial_histogram_buffer = createPartialHistogramBuffer(context,   num_groups);
    if (!partial_histogram_buffer)
    {
        return EXIT_FAILURE;
   }

    clSetKernelArg(histogram_rgba_fp, 0, sizeof(cl_mem), &input_image_fp32);
    clSetKernelArg(histogram_rgba_fp, 1, sizeof(int), &NUM_PIXELS_PER_WORK_ITEM);
    clSetKernelArg(histogram_rgba_fp, 2, sizeof(cl_mem), &partial_histogram_buffer);
    
    clSetKernelArg(histogram_sum_partial_results_fp, 0, sizeof(cl_mem), &partial_histogram_buffer);
    clSetKernelArg(histogram_sum_partial_results_fp, 1, sizeof(int), &num_groups);
    clSetKernelArg(histogram_sum_partial_results_fp, 2, sizeof(cl_mem), &histogram_buffer);
    
    // verify that the kernel works correctly.  also acts as a warmup
    err = clEnqueueNDRangeKernel(queue, histogram_rgba_fp, 2, NULL, global_work_size, local_work_size, 0, NULL, NULL);
    if (err)
    {
        printf("clEnqueueNDRangeKernel() failed for histogram_rgba_fp kernel. (%d)\n", err);
        return EXIT_FAILURE;
    }
    
    // verify that the kernel works correctly.  also acts as a warmup
    clGetKernelWorkGroupInfo(histogram_sum_partial_results_fp, device, CL_KERNEL_WORK_GROUP_SIZE, sizeof(size_t), &workgroup_size, NULL);
    if (workgroup_size < 256)
    {
        printf("A min. of 256 work-items in work-group is needed for histogram_sum_partial_results_fp kernel. (%d)\n", (int)workgroup_size);
        return EXIT_FAILURE;
    }
    partial_global_work_size[0] = 256*3;
    partial_local_work_size[0] = (workgroup_size > 256) ? 256 : workgroup_size;
    err = clEnqueueNDRangeKernel(queue, histogram_sum_partial_results_fp, 1, NULL, partial_global_work_size, partial_local_work_size, 0, NULL, NULL);
    if (err)
    {
        printf("clEnqueueNDRangeKernel() failed for histogram_sum_partial_results_fp kernel. (%d)\n", err);
        return EXIT_FAILURE;
    }

    ref_histogram_results = (unsigned int *)generate_reference_histogram_results_fp32(image_data_fp32, IMAGE_WIDTH, IMAGE_HEIGHT);
    err = clEnqueueReadBuffer(queue, histogram_buffer, CL_TRUE, 0, 257*3*sizeof(unsigned int), histogram_results, 0, NULL, NULL);
    if (err)
    {
        printf("clEnqueueReadBuffer() failed. (%d)\n", err);
        return EXIT_FAILURE;
    }
    verify_histogram_results("Image Histogram for image type = CL_RGBA, CL_FLOAT", histogram_results, ref_histogram_results, 257*3);

    // now measure performance
    err = clEnqueueMarker(queue, &events[0]);
    if (err)
    {
        printf("clEnqeueMarker() failed for histogram_rgba_fp kernel. (%d)\n", err);
        return EXIT_FAILURE;
    }
    for (i=0; i<NUM_ITERATIONS; i++)
    {
        err = clEnqueueNDRangeKernel(queue, histogram_rgba_fp, 2, NULL, global_work_size, local_work_size, 0, NULL, NULL);
        if (err)
        {
            printf("clEnqueueNDRangeKernel() failed for histogram_rgba_fp kernel. (%d)\n", err);
            return EXIT_FAILURE;
        }
        
        err = clEnqueueNDRangeKernel(queue, histogram_sum_partial_results_fp, 1, NULL, partial_global_work_size, partial_local_work_size, 0, NULL, NULL);
        if (err)
        {
            printf("clEnqueueNDRangeKernel() failed for histogram_sum_partial_results_fp kernel. (%d)\n", err);
            return EXIT_FAILURE;
        }        
    }
    err = clEnqueueMarker(queue, &events[1]);
    if (err)
    {
        printf("clEnqeueMarker() failed for histogram_rgba_fp kernel. (%d)\n", err);
        return EXIT_FAILURE;
    }
    err = clWaitForEvents(1, &events[1]);
    if (err)
    {
        printf("clWaitForEvents() failed for histogram_rgba_fp kernel. (%d)\n", err);
        return EXIT_FAILURE;
    }    
    
    err = clGetEventProfilingInfo(events[0], CL_PROFILING_COMMAND_QUEUED, sizeof(cl_long), &time_start, NULL);
    err |= clGetEventProfilingInfo(events[1], CL_PROFILING_COMMAND_END, sizeof(cl_long), &time_end, NULL);
    if (err)
    {
        printf("clGetEventProfilingInfo() failed for histogram_rgba_fp kernel. (%d)\n", err);
        return EXIT_FAILURE;
    }    
        
    printf("Image dimensions: %d x %d pixels, Image type = CL_RGBA, CL_FLOAT\n", IMAGE_WIDTH, IMAGE_HEIGHT);
    printf("Time to compute histogram = %g ms\n", (double)(time_end - time_start) * 1e-9 * 1000.0 / (double)NUM_ITERATIONS);
    
    std::cout << "release resouces" << std::endl;
    clReleaseEvent(events[0]);
    clReleaseEvent(events[1]);

    free(ref_histogram_results);
    free(histogram_results);
    free(image_data_unorm8);
    free(image_data_fp32);

    clReleaseKernel(histogram_rgba_unorm8);
    clReleaseKernel(histogram_rgba_fp);
    clReleaseKernel(histogram_sum_partial_results_unorm8);
    clReleaseKernel(histogram_sum_partial_results_fp);
    
    clReleaseProgram(program);    
    clReleaseMemObject(partial_histogram_buffer);
    clReleaseMemObject(histogram_buffer);
    clReleaseMemObject(input_image_unorm8);
    clReleaseMemObject(input_image_fp32);
    
    return EXIT_SUCCESS;
}


/**
 * main
 */
int 
main(int argc, char **argv)
{

    int ret = test_histogram();
    if(ret != EXIT_SUCCESS) {
        return EXIT_FAILURE;
    }

    std::cout<< "test histogram Successfull" << std::endl;
    return EXIT_SUCCESS;

}

